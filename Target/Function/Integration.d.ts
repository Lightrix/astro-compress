import type Action from "@playform/pipe/Target/Interface/Action.js";
import type Interface from "../Interface/Integration.js";
export declare const Import: {
    WriteSharp: import("../Interface/Image/Writesharp.js").default;
    Merge: <Ts extends readonly unknown[]>(...objects: Ts) => import("deepmerge-ts").DeepMergeHKT<Ts, Readonly<{
        DeepMergeRecordsURI: "DeepMergeRecordsDefaultURI";
        DeepMergeArraysURI: "DeepMergeArraysDefaultURI";
        DeepMergeSetsURI: "DeepMergeSetsDefaultURI";
        DeepMergeMapsURI: "DeepMergeMapsDefaultURI";
        DeepMergeOthersURI: "DeepMergeLeafURI";
        DeepMergeFilterValuesURI: "DeepMergeFilterValuesDefaultURI";
    }>, Readonly<{
        key: PropertyKey;
        parents: ReadonlyArray<Readonly<Record<PropertyKey, unknown>>>;
    }>>;
    Option: {
        Path: string;
        Cache: {
            Search: string;
            Folder: string;
        };
        Logger: 2;
        Action: {
            Failed: ({ Input }: import("@playform/pipe/Target/Interface/File.js").default) => Promise<string>;
            Passed: ({ Before, Buffer }: import("@playform/pipe/Target/Interface/File.js").default) => Promise<boolean>;
            Accomplished: ({ Input, Before, After }: import("@playform/pipe/Target/Interface/File.js").default) => Promise<string>;
            Changed: (Plan: import("@playform/pipe/Target/Interface/Plan.js").default) => Promise<any>;
            Read: ({ Input }: import("@playform/pipe/Target/Interface/File.js").default) => Promise<string>;
            Wrote: ({ Buffer }: import("@playform/pipe/Target/Interface/File.js").default) => Promise<import("@playform/pipe/Target/Type/Buffer.js").Type>;
            Fulfilled: ({ File }: import("@playform/pipe/Target/Interface/Plan.js").default) => Promise<string | false>;
        };
        File: string;
        Exclude: false;
        CSS: {
            csso: import("../Interface/CSS/csso.js").default;
            lightningcss: import("../Interface/CSS/lightningcss.js").default;
        };
        HTML: {
            "html-minifier-terser": {
                caseSensitive: true;
                collapseInlineTagWhitespace: false;
                collapseWhitespace: true;
                continueOnParseError: true;
                html5: true;
                ignoreCustomComments: RegExp[];
                ignoreCustomFragments: never[];
                includeAutoGeneratedTags: true;
                keepClosingSlash: true;
                minifyCSS: true;
                minifyJS: true;
                minifyURLs: false;
                noNewlinesBeforeTagClose: true;
                preventAttributesEscaping: false;
                processConditionalComments: false;
                processScripts: string[];
                quoteCharacter: string;
                removeAttributeQuotes: true;
                removeComments: true;
                removeScriptTypeAttributes: true;
                removeStyleLinkTypeAttributes: true;
                removeTagWhitespace: false;
                sortAttributes: true;
                sortClassName: true;
                trimCustomFragments: true;
                useShortDoctype: false;
            };
        };
        Image: {
            sharp: import("../Interface/Image/sharp.js").default;
        };
        JavaScript: {
            terser: {
                ecma: 5;
                enclose: false;
                keep_classnames: false;
                keep_fnames: false;
                ie8: false;
                module: false;
                safari10: false;
                toplevel: false;
                format: {
                    comments: false;
                };
            };
        };
        SVG: {
            svgo: {
                multipass: true;
                js2svg: {
                    indent: number;
                    pretty: false;
                };
                plugins: "preset-default"[];
            };
        };
        Map: import("../Interface/Map.js").default;
        Parser: import("../Interface/Parser.js").default;
    };
    Pipe: typeof import("@playform/pipe").default;
    Bytes: import("@playform/pipe/Target/Interface/Bytes.js").default;
    "Option/Pipe": typeof import("@playform/pipe/Target/Variable/Option.js");
    buffer: {
        default: typeof import("buffer");
        isUtf8(input: Buffer | ArrayBuffer | NodeJS.TypedArray): boolean;
        isAscii(input: Buffer | ArrayBuffer | NodeJS.TypedArray): boolean;
        transcode(source: Uint8Array, fromEnc: import("buffer").TranscodeEncoding, toEnc: import("buffer").TranscodeEncoding): Buffer;
        resolveObjectURL(id: string): import("buffer").Blob | undefined;
        INSPECT_MAX_BYTES: number;
        kMaxLength: number;
        kStringMaxLength: number;
        constants: {
            MAX_LENGTH: number;
            MAX_STRING_LENGTH: number;
        };
        SlowBuffer: {
            new (size: number): Buffer;
            prototype: Buffer;
        };
        Buffer: BufferConstructor;
        Blob: typeof import("buffer").Blob;
        File: typeof import("buffer").File;
        atob: typeof atob;
        btoa: typeof btoa;
    };
    csso: {
        default: typeof import("csso");
        minify(source: string, options?: import("csso").MinifyOptions & import("csso").CompressOptions): import("csso").Result;
        minifyBlock(source: string, options?: import("csso").MinifyOptions & import("csso").CompressOptions): import("csso").Result;
        version: string;
        syntax: typeof import("css-tree") & {
            compress(ast: import("css-tree").CssNode, options?: import("csso").CompressOptions): {
                ast: import("css-tree").CssNode;
            };
            specificity(simpleSelector: import("css-tree").CssNode): [a: number, b: number, c: number];
        };
    };
    "html-minifier-terser": typeof import("html-minifier-terser");
    "kleur/colors": {
        default: typeof import("kleur/colors");
        print(input: string | boolean | number): string;
        print(input: undefined | void): undefined;
        print(input: null): null;
        $: {
            enabled: boolean;
        };
        black: import("kleur/colors").Colorize;
        red: import("kleur/colors").Colorize;
        green: import("kleur/colors").Colorize;
        yellow: import("kleur/colors").Colorize;
        blue: import("kleur/colors").Colorize;
        magenta: import("kleur/colors").Colorize;
        cyan: import("kleur/colors").Colorize;
        white: import("kleur/colors").Colorize;
        gray: import("kleur/colors").Colorize;
        grey: import("kleur/colors").Colorize;
        bgBlack: import("kleur/colors").Colorize;
        bgRed: import("kleur/colors").Colorize;
        bgGreen: import("kleur/colors").Colorize;
        bgYellow: import("kleur/colors").Colorize;
        bgBlue: import("kleur/colors").Colorize;
        bgMagenta: import("kleur/colors").Colorize;
        bgCyan: import("kleur/colors").Colorize;
        bgWhite: import("kleur/colors").Colorize;
        reset: import("kleur/colors").Colorize;
        bold: import("kleur/colors").Colorize;
        dim: import("kleur/colors").Colorize;
        italic: import("kleur/colors").Colorize;
        underline: import("kleur/colors").Colorize;
        inverse: import("kleur/colors").Colorize;
        hidden: import("kleur/colors").Colorize;
        strikethrough: import("kleur/colors").Colorize;
    };
    lightningcss: {
        default: typeof import("lightningcss");
        transform<C extends import("lightningcss").CustomAtRules>(options: import("lightningcss").TransformOptions<C>): import("lightningcss").TransformResult;
        transformStyleAttribute(options: import("lightningcss").TransformAttributeOptions): import("lightningcss").TransformAttributeResult;
        browserslistToTargets(browserslist: string[]): import("lightningcss").Targets;
        bundle<C extends import("lightningcss").CustomAtRules>(options: import("lightningcss").BundleOptions<C>): import("lightningcss").TransformResult;
        bundleAsync<C extends import("lightningcss").CustomAtRules>(options: import("lightningcss").BundleAsyncOptions<C>): Promise<import("lightningcss").TransformResult>;
        composeVisitors<C extends import("lightningcss").CustomAtRules>(visitors: import("lightningcss").Visitor<C>[]): import("lightningcss").Visitor<C>;
        Features: {
            Nesting: 1;
            NotSelectorList: 2;
            DirSelector: 4;
            LangSelectorList: 8;
            IsSelector: 16;
            TextDecorationThicknessPercent: 32;
            MediaIntervalSyntax: 64;
            MediaRangeSyntax: 128;
            CustomMediaQueries: 256;
            ClampFunction: 512;
            ColorFunction: 1024;
            OklabColors: 2048;
            LabColors: 4096;
            P3Colors: 8192;
            HexAlphaColors: 16384;
            SpaceSeparatedColorNotation: 32768;
            FontFamilySystemUi: 65536;
            DoublePositionGradients: 131072;
            VendorPrefixes: 262144;
            LogicalProperties: 524288;
            Selectors: 31;
            MediaQueries: 448;
            Colors: 64512;
        };
    };
    sharp: typeof import("sharp");
    svgo: {
        default: typeof import("svgo");
        optimize(input: string, config?: import("svgo").Config): import("svgo").Output;
        loadConfig(configFile: string, cwd?: string): Promise<import("svgo").Config>;
        loadConfig(configFile?: null, cwd?: string): Promise<import("svgo").Config | null>;
    };
    terser: typeof import("terser");
    path: {
        default: import("path").PlatformPath;
        normalize(path: string): string;
        join(...paths: string[]): string;
        resolve(...paths: string[]): string;
        matchesGlob(path: string, pattern: string): boolean;
        isAbsolute(path: string): boolean;
        relative(from: string, to: string): string;
        dirname(path: string): string;
        basename(path: string, suffix?: string): string;
        extname(path: string): string;
        sep: "\\" | "/";
        delimiter: ";" | ":";
        parse(path: string): import("path").ParsedPath;
        format(pathObject: import("path").FormatInputPathObject): string;
        toNamespacedPath(path: string): string;
        posix: import("path").PlatformPath;
        win32: import("path").PlatformPath;
    };
};
/**
 * @module Integration
 *
 */
export declare let System: string;
declare const _default: Interface;
export default _default;
export declare const Search: string;
export declare let _Action: Action;
